<?php

namespace DigraphCMS\UI\Pagination;

use Countable;
use DigraphCMS\Events\Dispatcher;
use DigraphCMS\HTML\ConditionalContainer;
use DigraphCMS\HTML\DIV;
use DigraphCMS\HTML\Tag;
use DigraphCMS\UI\Notifications;
use DigraphCMS\UI\Paginator;
use Iterator;

class PaginatedList extends Tag
{
    protected static $counter = 0;
    protected $paginator = false;
    protected $count;
    protected $tag = 'div';
    protected $source;
    protected $body, $top, $bottom, $before, $after;
    protected $items;
    protected $callback;

    /**
     * @param mixed $source
     * @param callable $callback
     */
    public function __construct($source, ?callable $callback)
    {
        $this->setId(md5(get_called_class()) . '--' . static::$counter++);
        $this->addClass('paginated-section');
        $this->addClass('navigation-frame');
        $this->setData('target', '_top');
        $this->source = $source;
        $this->callback = $callback ?? function ($item) {
            return $item;
        };
    }

    public function paginator(): Paginator
    {
        if ($this->paginator === false) {
            if ($this->source instanceof Countable) $this->count = $this->source->count();
            elseif (is_array($this->source)) $this->count = count($this->source);
            $this->paginator = new Paginator($this->count);
        }
        return $this->paginator;
    }

    public function children(): array
    {
        $children = [];
        $children[] = $this->top();
        $children[] = $this->before();
        $children[] = $this->body();
        $children[] = $this->after();
        $children[] = $this->bottom();
        return $children;
    }

    /**
     * Get the items that should be added to the body, which are generated by
     * applying the callback to the necessary items
     *
     * @return array
     */
    protected function items(): array
    {
        if ($this->items === null) {
            // Use DB offset/limit if available
            if (method_exists($this->source, 'offset') && method_exists($this->source, 'limit') && method_exists($this->source, 'fetchAll')) {
                $source = clone $this->source;
                $source->offset($this->paginator()->startItem());
                $source->limit($this->paginator()->perPage());
                $this->items = $source->fetchAll();
            }
            // Use built-in array_slice to cut out the requested section of an array
            elseif (is_array($this->source)) {
                $this->items = array_slice(
                    $this->source,
                    $this->paginator()->startItem(),
                    $this->paginator()->endItem() - $this->paginator()->startItem()
                );
            }
            // Straight Iterators aren't especially efficient, because you have to iterate through 
            // everything prior to the first item 
            elseif ($this->source instanceof Iterator) {
                $source = clone $this->source;
                $this->source->rewind();
            }
            // Try to hand off to Dispatcher so that we can extend this
            elseif ($this->items = Dispatcher::firstValue('onPaginatedList', [$this->source])) {
                // does nothing, assignment happened in the elseif statement
            }
            // Throw an exception if we don't know how to handle this source
            else {
                throw new \Exception("Unable to paginate source");
            }
            // map callback onto items
            $this->items = array_filter(array_map(
                function ($item) {
                    return $this->runCallback($item);
                },
                $this->items
            ));
        }
        // return generated items list
        return $this->items;
    }

    protected function runCallback($item)
    {
        return call_user_func($this->callback, $item) ?? false;
    }

    public function before(): ConditionalContainer
    {
        if (!$this->before) {
            $this->before = new ConditionalContainer;
            $this->before->addClass('paginated-section__before');
            $this->before->addChild($this->paginator());
            $this->before->addChild('<span class="paginated-section__spacer"></span>');
        }
        return $this->before;
    }

    public function after(): ConditionalContainer
    {
        if (!$this->after) {
            $this->after = new ConditionalContainer;
            $this->after->addClass('paginated-section__after');
            $this->after->addChild($this->paginator());
            $this->before->addChild('<span class="paginated-section__spacer"></span>');
        }
        return $this->after;
    }

    public function top(): ConditionalContainer
    {
        if (!$this->top) {
            $this->top = new ConditionalContainer;
            $this->top->addClass('paginated-section__top');
        }
        return $this->top;
    }

    public function bottom(): ConditionalContainer
    {
        if (!$this->bottom) {
            $this->bottom = new ConditionalContainer;
            $this->bottom->addClass('paginated-section__bottom');
        }
        return $this->bottom;
    }

    public function body(): Tag
    {
        if (!$this->body) {
            $this->body = new DIV;
            $this->body->addClass('paginated-section__body');
            $items = $this->items();
            if (!$items) Notifications::printNotice('Nothing to display');
            foreach ($items as $item) {
                $this->body->addChild($item);
            }
        }
        return $this->body;
    }
}
